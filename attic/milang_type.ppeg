%%@skip-on-include
atomic <- type_top / module_name / infix / bindable_function_name ~;
%%@end-skip

type_top <- type_primary (space? '->' space? type_primary)* `
	log_rule(?FUNCTION_NAME, Node),
	case Node of
		[T , []] ->
			T;
		[FirstArg, RawTail] ->
			FixedTail = [TailType || [_, _, _, TailType] <- RawTail],
			ArgsWithReturn = [FirstArg | FixedTail],
			[Return | ReversedArgs] = lists:reverse(ArgsWithReturn),
			Args = lists:reverse(ReversedArgs),
			{type_function, simple_idx(Idx), Args, Return}
	end
`;

type_primary <- type_concrete / type_variable / sub_type_expression ~;

sub_type_expression <- '(' space? type_top space? ')' `
	[_, _, T, _, _] = Node,
	T
`;

type_variable <- variable `
	setelement(1, Node, type_variable)
`;

type_concrete <- type_name (space type_arg)* `
	[BaseName, ArgsWithSpaces] = Node,
	Args = [Arg || [_, Arg] <- ArgsWithSpaces],
	{type_concrete, simple_idx(Idx), BaseName, Args}
`;

type_arg <- type_name / type_variable / sub_type_expression `
	io:format("blerg type arg node! ~p~n", [Node]),
	case Node of
		[_, _, Type, _, _] ->
			Type;
		{local_type_name, _, _} = Name ->
			{type_concrete, simple_idx(Idx), Name, []};
		{remote_type_name, _, _, _} = Name ->
			{type_concrete, simple_idx(Idx), Name, []};
		_ ->
			Node
	end
`;

%%@import milang_atomic.ppeg

%%@append milang_helpers.hrl
