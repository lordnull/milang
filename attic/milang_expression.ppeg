%%@skip-on-include
expression_fake_head <- expression / variable / bindable_function_name ~;
%%@end-skip

expression <- head:expr_primary tail:(space? infix space? expr_primary)* `
	log_rule(expression, Node),
	Head = proplists:get_value(head, Node),
	TailWithSpaces = proplists:get_value(tail, Node, []),
	Tail = [{Op, Expr} || [_, Op, _, Expr] <- TailWithSpaces],
	case Tail of
		[] ->
			Head;
		_ ->
			{expression, simple_idx(Idx), Head, Tail}
	end
`;

expr_primary <- call / literal / sub_expression `
	log_rule(expr_primary, Node),
	Node
`;

sub_expression <- '(' space? expr:expression space? ')' `
	log_rule(sub_expression, Node),
	Expr = proplists:get_value(expr, Node),
	{expression, simple_idx(Idx), Expr}
`;

call <- call:(function_name / type_name) args:(space argument)* `
	log_rule(call, Node),
	Call = proplists:get_value(call, Node),
	ArgsWithSpaces = proplists:get_value(args, Node, []),
	Args = [A || [_, A] <- ArgsWithSpaces],
	{call, simple_idx(Idx), Call, Args}
`;

argument <- literal / function_name / type_name / sub_expression ~;

literal <- literal_list / literal_map / literal_record / literal_string / literal_number ~;

literal_list <- '[' elements:(space? list_element)* space? ']' `
	log_rule(?FUNCTION_NAME, Node),
	DirtyElements = proplists:get_value(elements, Node, []),
	Elements = [E || [_, E] <- DirtyElements],
	{literal_list, simple_idx(Idx), Elements}
`;

list_element <- ',' space? expression `
	log_rule(?FUNCTION_NAME, Node),
	[_, _, Element] = Node,
	Element
`;

literal_map <- '#{' (space? map_entry)* space? '}#' `
	log_rule(?FUNCTION_NAME, Node),
	[_, DirtyFields, _, _] = Node,
	Fields = [F || [_, F] <- DirtyFields],
	{literal_map, simple_idx(Idx), Fields}
`;

map_entry <- ',' space? expression space? '=' space? expression `
	log_rule(?FUNCTION_NAME, Node),
	[_, _, Key, _, _, _, Value] = Node,
	{map_entry, simple_idx(Idx), Key, Value}
`;

literal_record <- '{' (space? record_field)* space? '}' `
	log_rule(?FUNCTION_NAME, Node),
	[_, DirtyFields, _, _] = Node,
	Fields = [F || [_, F] <- DirtyFields],
	{literal_record, simple_idx(Idx), Fields}
`;

record_field <- ',' space? record_field_key space? ':=' space? expression `
	[_, _, Key, _, _, _, Value] = Node,
	{record_field, simple_idx(Idx), Key, Value}
`;

record_field_key <- downcase_name / ( [1-9] [0-9]* )  ~;

literal_string <- '"' string:(!'"' ("\\\\" / '\\"' / .))* '"' `
	String = proplists:get_value(string, Node),
	{literal_string, simple_idx(Idx), unicode:characters_to_binary(String)}
`;

literal_number <- '-'? [0-9]+ ('.' [0-9]+)? `
	case Node of
		[_, _, []] ->
			{literal_integer, simple_idx(Idx), binary_to_integer(unicode:characters_to_binary(Node))};
		[_, _, [_, _]] ->
			{literal_float, simple_idx(Idx), binary_to_float(unicode:characters_to_binary(Node))}
	end
`;

%%@import milang_atomic.ppeg

%%@append milang_helpers.hrl
