module <- space? (declaration space?)*`
	[_, DeclarationsWithSpaces] = Node,
	[ Declaration || [Declaration, _] <- DeclarationsWithSpaces]
`;

declaration
	<- module_declaration
	/  import_declaration
	/  alias_declaration
	/  type_declaration
	/  class_declaration
	/  spec_declaration
	/  function_declaration ~;

module_declaration <- '-module' space modName:module_name space 'exposing' space? exposing:exposing_list? space? declaration_seperator `
	Name = proplists:get_value(modName, Node),
	Exports = proplists:get_value(exposing, Node, []),
	{module, simple_idx(Idx), Name, Exports}
`;

import_declaration <- '-import' space mod:type_name (space 'as' space alias:upcase_name)? (space 'exposing' space? exposing:exposing_list)? space? declaration_seperator`
	Mod = proplists:get_value(mod, Node),
	Alias = proplists:get_value(alias, Node),
	Exposing = proplists:get_value(exposing, Node, []),
	{import, simple_idx(Idx), Mod, Alias, Exposing}
`;

alias_declaration <- '-alias' constraints:(space constraint_section)? space name:upcase_name args:(space downcase_name)* space? '=' space? actual:literal_type space? '.' `
	NewName = proplists:get_value(name, Node),
	Actual = proplists:get_value(actual, Node),
	Constraints = proplists:get_value(constraints, Node, []),
	DirtyArgs = proplists:get_value(args, Node, []),
	Args = [A || [_, A] <- DirtyArgs],
	{alias, simple_idx(Idx), NewName, Args, Constraints, Actual}
`;

type_declaration <- '-type' constraints:(space constraint_section)? space name:upcase_name args:(space downcase_name)* constructors:(space? type_constructor)+ space? '.' `
	Name = proplists:get_value(name, Node),
	Constraints = proplists:get_value(constraints, Node, []),
	DirtyArgs = proplists:get_value(args, Node, []),
	Args = [A || [_, A] <- DirtyArgs],
	DirtyConstructors = proplists:get_value(constructors, Node, []),
	Constructors = [C || [_, C] <- DirtyConstructors],
	{type, simple_idx(Idx), Name, Constraints, Args, Constructors}
`;

type_constructor <- '|' space? name:upcase_name args:(space (type_primary / literal_type_record))* `
	Name = proplists:get_value(name, Node),
	DirtyArgs = proplists:get_value(args, Node, []),
	Args = [A || [_, A] <- DirtyArgs],
	{type_constructor, simple_idx(Idx), Name, Args}
`;

literal_type <- type_top / literal_type_record ~;

literal_type_record <- (';' space? downcase_name space? ':=' space? literal_type space?)+ '.' `
	Fields = [{Name, Type} || [_, _, Name, _, _, _, Type, _] <- Node],
	{literal_type_record, simple_idx(Idx), Fields}
`;

constraint_section <- '{' (space? constraint_item )+ space? '}' `
	[_, DirtyItems, _, _] = Node,
	[I || [_, I] <- DirtyItems]
`;

constraint_item <- ',' space? downcase_name space? ':=' space? type_concrete `
	[{Variable, Constraint} || [_, _, Variable, _, _, _, Constraint] <- Node]
`;

class_declaration <- '-class' (space? constraint_section)? space name:upcase_name args:(space downcase_name)+ space? (class_member space?)+ '.' ~;

class_member <- '|' space? (class_definition / class_default) ~;

class_definition <- bindable_function_name space? ':' space? type_top ~;

class_default <- bindable_function_name (space downcase_name)* space? ':=' space? expression space? '.' ~;

spec_declaration <- name:bindable_function_name space? ':' space? type_spec:type_top space? '.' `
	Name = proplists:get_value(name, Node),
	Spec = proplists:get_value(type_spec, Node),
	{specification, simple_idx(Idx), Name, Spec}
`;

function_declaration <- name:bindable_function_name (space variable)* space? ':=' space? expression space? '.' ~;

%function_declaration <- name:bindable_function_name args:(space variable)* space? ':=' space? body:function_body space? declaration_seperator`
%	Name = proplists:get_value(name, Node),
%	Args = proplists:get_value(args, Node),
%	Body = proplists:get_value(body, Node),
%	{function, simple_idx(Idx), Name, Args, Body}
%`;
%
%function_body <- bindings:(binding space?) out:expression`
%	Bindings = proplists:get_value(bindings, Node, []),
%	Out = proplists:get_value(out, Node),
%	{function_body, simple_idx(Idx), Bindings, Out}
%`;

%binding <- ',' space? name:local_function_name space? ':=' expr:expression `
%	Name = proplists:get_value(name, Node),
%	Expr = proplists:get_value(expr, Node),
%	{binding, simple_idx(Idx), Name, Expr}
%`;
%
exposing_list <- '[' (space? exposing_item)* space? ']' `
	[_, DirtyElements, _, _] = Node,
	Elements = [E || [_, E] <- DirtyElements],
	{exposing, simple_idx(Idx), Elements}
`;

exposing_item <- ',' space? (upcase_name / local_function_name) `
	[_, _, Elem] = Node,
	Elem
`;

declaration_seperator <- '.' ~;

%list_seperator <- ',' ~;

%%@import milang_expression.ppeg

%%@import milang_atomic.ppeg

%%@import milang_type.ppeg

%%@append milang_helpers.hrl

